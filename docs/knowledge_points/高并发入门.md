```yaml
title: 高并发入门
author: samin
date: 2021-10-20
```

# 入门基础

## 数据化的指标

分清楚并发量和QPS来衡量高并发系统

了解自己系统的总用户量、活跃用户量，平峰和高峰时的QPS和TPS等关键数据

## 对高并发方案细节的掌握

方案要关注的技术点和可能带来的副作用

比如读性能有瓶颈会引入缓存，但是忽视了缓存命中率、热点key、数据一致性等问题

## 高并发设计不等同于性能优化

除了并发编程、多级缓存、异步化、水平扩容等，不可忽视高可用设计、服务治理和运维保障

## 掌握大方案，却忽视最基本的东西

区分垂直分层、水平分区、缓存等大思路

分析数据结构是否合理，算法是否高效，如何从**最根本**的IO和计算两个维度去做细节优化

# 如何理解高并发？

## 什么是高并发

高并发意味着大流量，需要运用技术手段抵抗流量的冲击，这些手段好比操作流量，能让流量更平稳地被系统所处理，带给用户更好的体验

## 场景

我们常见的高并发场景有：淘宝的双11、春运时的抢票、微博大V的热点新闻等。除了这些典型事情，每秒几十万请求的秒杀系统、每天千万级的订单系统、每天亿级日活的信息流系统等，都可以归为高并发

## 多大并发才算高并发

1、不能只看数字，要看**具体的业务场景**。不能说10W QPS的秒杀是高并发，而1W QPS的信息流就不是高并发。信息流场景涉及复杂的推荐模型和各种人工策略，它的业务逻辑可能比秒杀场景复杂10倍不止。因此，不在同一个维度，没有任何比较意义

2、业务都是从0到1做起来的，并发量和QPS只是参考指标，最重要的是：在业务量逐渐变成原来的10倍、100倍的过程中，你是否用到了高并发的处理方法去演进你的系统，从架构设计、编码实现、甚至产品方案等维度去预防和解决高并发引起的问题。而不是一味的升级硬件、加机器做水平扩展

> 此外，各个高并发场景的业务特点完全不同：有读多写少的信息流场景、有读多写多的交易场景

## TPS / QPS / 并发数扫盲

TPS(transaction per second)：单位时间内处理事务的数量

QPS(query per second)：单位时间内请求的数量

并发数：并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量

### TPS vs QPS

假设一次用户操作，只涉及一个Api，那么TPS和QPS指标数相同，假设一次用户操作，涉及了 N 个 Api，则 TPS 为 1，QPS 为 1 * N

### QPS vs 并发数

QPS 是指单位时间客户端发出请求的总量，并发数是指服务端单位时间能够处理响应的总量

并发数 <= QPS

## 是否有通用的技术方案解决不同场景的高并发问题

大的思路可以借鉴，别人的方案也可以参考，但是真正落地过程中，细节上还会有无数的坑。另外，由于软硬件环境、技术栈、以及产品逻辑都没法做到完全一致，这些都会导致同样的业务场景，就算用相同的技术方案也会面临不同的问题，这些坑还得一个个趟

# 高并发系统设计的目标是什么？

## 宏观目标

- 高性能

    性能体现了系统的并行处理能力，在有限的硬件投入下，提高性能意味着节省成本。同时，性能也反映了用户体验，响应时间分别是100毫秒和1秒，给用户的感受是完全不同的

- 高可用

    表示系统可以正常服务的时间。一个全年不停机、无故障；另一个隔三差五出线上事故、宕机，用户肯定选择前者。另外，如果系统只能做到90%可用，也会大大拖累业务

- 高扩展（弹性）

    表示系统的扩展能力，流量高峰时能否在短时间内完成扩容，更平稳地承接峰值流量，比如双11活动、明星离婚等热点事件

> 三者互相关联、甚至也会相互影响
> 考虑系统的扩展能力，你会将服务设计成无状态的，这种集群设计保证了高扩展性，其实也间接提升了系统的性能和可用性
> 为了保证可用性，通常会对服务接口进行超时设置，以防大量线程阻塞在慢请求上造成系统雪崩，那超时时间设置成多少合理呢？一般，我们会参考依赖服务的性能表现进行设置

## 微观目标

### 性能指标

- 平均响应时间

    对慢请求不敏感，比如1万次请求，其中9900次是1ms，100次是100ms，则平均响应时间为1.99ms

- TP90、TP99等分位值

    假设100次请求，请求完之后把这100次请求结果按照响应时间从小到大进行排序，第90和第99个位置成为 TP90 和 TP99，更能客观反应系统的性能

- 吞吐量

    和响应时间呈反比，比如响应时间是1ms，则吞吐量为每秒1000次

> 通常，设定性能目标时会兼顾吞吐量和响应时间
> 比如这样表述：在每秒1万次请求下，AVG控制在50ms以下，TP99控制在100ms以下
> 对于高并发系统，AVG和TP分位值必须同时要考虑
> 另外，从用户体验角度来看，200毫秒被认为是第一个分界点，用户感觉不到延迟，1秒是第二个分界点，用户能感受到延迟，但是可以接受
> 因此，对于一个健康的高并发系统，TP99应该控制在200毫秒以内，TP999或者TP9999应该控制在1秒以内

# 高并发的实践方案有哪些？

## 通用设计方法

### 纵向扩展（scale-up）

提升单机处理能力

1. 提升单机的硬件性能

    通过增加内存、 CPU核数、存储容量、或者将磁盘升级成SSD等堆硬件的方式来提升

2. 提升单机的软件性能

   使用缓存减少IO次数，使用并发或者异步的方式增加吞吐量

> 单机进行高并发接口测试，需要知道单台机子能够支撑的带宽和CPU线程数量

### 横向扩展（scale-out）

单机性能存在极限，最终需要引入横向扩展，通过集群部署进一步提高并发处理能力

1. 做好分层架构 

    这是横向扩展的前提，因为高并发系统往往业务复杂，通过分层处理可以简化复杂问题，更容易做到横向扩展

2. 各层进行水平扩展

   无状态水平扩容，有状态做分片路由。业务集群通常能设计成**无状态**的，而数据库和缓存往往是有状态的，因此需要设计分区键做好存储分片，当然也可以通过主从同步、读写分离的方案提升读性能

## 具体实践方案

### 高性能

1. 集群部署，通过负载均衡减轻单机压力

2. 多级缓存，包括静态数据使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、数据一致性等问题的处理

3. 分库分表和索引优化，以及借助搜索引擎解决复杂查询问题

4. 考虑NoSQL数据库的使用，比如HBase、TiDB等，但是团队必须熟悉这些组件，且有较强的运维能力

5. 异步化，将次要流程通过多线程、MQ、甚至延时任务进行异步处理

6. 限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、Nginx接入层的限流、服务端的限流

7. 对流量进行 削峰填谷 ，通过 MQ承接流量

8. 并发处理，通过多线程将串行逻辑并行化

9. 预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可

10.  缓存预热 ，通过异步 任务 提前 预热数据到本地缓存或者分布式缓存中

11. 减少IO次数，比如数据库和缓存的批量读写、RPC的批量接口支持、或者通过冗余数据的方式干掉RPC调用

12. 减少IO时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等

13. 程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的算法

14. 各种池化技术的使用和池大小的设置，包括HTTP请求池、线程池（考虑CPU密集型还是IO密集型设置核心参数）、数据库和Redis连接池等

15. JVM优化，包括新生代和老年代的大小、GC算法的选择等，尽可能减少GC频率和耗时

16. 锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突

> 上述方案无外乎从**计算和 IO **两个维度考虑所有可能的优化点，需要有配套的监控系统实时了解当前的性能表现，并支撑你进行性能瓶颈分析，然后再遵循二八原则，抓主要矛盾进行优化

### 高可用

1. 对等节点的故障转移，Nginx和服务治理框架均支持一个节点失败后访问另一个节点

2. 非对等节点的故障转移，通过心跳检测并实施主备切换（比如redis的哨兵模式或者集群模式、MySQL的主从切换等）

3. 接口层面的超时设置、重试策略和幂等设计

4. 降级处理：保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路

5. 限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码

6. MQ场景的消息可靠性保证，包括producer端的重试机制、broker侧的持久化、consumer端的ack机制等

7. 灰度发布，能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量

8. 监控报警：全方位的监控体系，包括最基础的CPU、内存、磁盘、网络的监控，以及Web服务器、JVM、数据库、各类中间件的监控和业务指标的监控

9. 灾备演练：类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题

> 高并发重点要解决的问题是流量调度、服务调度
> 高可用的方案主要从冗余、取舍、系统运维3个方向考虑，同时需要有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理

### 高扩展

1. 合理的分层架构：比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）

2. 存储层的拆分：按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）

3. 业务层的拆分：最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求源拆（比如To C和To B，APP和H5 ）

> 弹性伸缩存在 gap（间隙）时间，所以一定会造成流量丢失

# 高并发设计架构设计三原则

- 简单

- 合适

- 演进

# 讨论高并发的切入点

对于项目中常用的各种中间件，比如缓存、消息队列、ElasticSearch 等，其实都是非常典型的高并发系统，你可以对某个中间件进行深入研究，然后面试时主动引导面试官到这种基础组件上，谈谈你的认识

如果你对自己的高并发设计能力很有信心，也可以让面试官给你拟定一个业务场景，然后给出你的设计方案

分别从高性能、高可用、高扩展这 3 个大方向做一次盘点，先找出技术亮点，每个亮点，一定要扎进细节里去做整理和深度思考，弄清楚 Why 和 How：为什么要用这个技巧？它是怎么发挥作用的？会引发哪些关联问题？最终取得了什么效果？此外，业务背景以及指标性的数据都要做到心中有数。找到亮点后，可以尝试找一条主脉络：比如按时间顺序、或者系统演进的顺序进行串联，这样比较符合高并发设计的基本原则，会让你的方案更接地气