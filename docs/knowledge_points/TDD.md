```yaml
title: TDD
author: samin
date: 2021-01-24
```

# 说明

Test-Driven Development 测试驱动

# 入门

The simple concept（概念） of TDD is to write and correct the failed tests before writing new code (before development).

Tests are nothing but requirement conditions that we need to test to fulfill them.

# 优势

- 以单元测试的通过为标准，并且通过不断重构让代码简单、无bug

- 给我们重构的信心（give us the confidence to refactor）；没有单元测试的代码，大家敢随便修改

- 好的单元测试就是文档 （documenting expected behavior）；几个实用的例子比文档让人感兴趣的多

# 特点

In TDD, you achieve 100% coverage test. Every single line of code is tested, unlike traditional testing.

# TDD / UTDD / ATDD / BDD

- UTDD（ Unit Test Driven Development ）**单元测试驱动开发**

大部分的 TDD 落地实践为 UTDD，所以容易让人产生 TDD 就是 UTDD 的想法。

- ATDD（ Acceptance Test Driven Development ）**验收测试驱动开发**

为了保障开发的程序具有可衡量的业务价值，通过验收文档编写更完善的测试用例，可以让开发人员反思如果开发了不需要经过验收测试的代码，为何要实施。

- BDD（ Behavior Driven development ）**行为驱动开发**

在落地 ATDD 的过程中，慢慢衍生出来和 TDD 方向一致且更具价值的产物。要求每个故事必须有一个通过 GWT 格式编写的行为测试。

|区别项|TDD|BDD|
|:---:|:---:|:---:|
|参与者|开发和测试|开发和客户|
|用例目的|方法的正确性|行为与结果的对比|
|解决问题|解决开发和测试脱节|解决开发和需求脱节|
|测试类型|白盒测试|黑盒测试|
|输入文档|通过需求文档拆分的测试用例|使用 GWT 格式编写的行为用例|
|安全感|中|高|
|执行速度|快|慢|

**BDD帮助开发人员设计(design)软件，TDD帮助开发人员测试(test)软件**

> 区分这些概念不是为了对号入座自己使用的具体开发过程，这样反而画地为牢，限制了团队的开发灵活度，应该结合项目落地实践，灵活的去编写更有价值的单元测试，而不必纠结自己用的是 TDD 还是 BDD。

# 容易混淆的 Test Doubles

TDD 是为了保证自身项目的代码质量，而不是致力于项目的整体运行情况，所以对涉及 DB、IO、WEB、API、Library 等操作的方法，采用 Mock 来消除这方面的影响。

同时 TDD 倡导尽可能快的测试速度，尽量不影响整体的构建速度，所以网络通信和其他项目的依赖调用造成的延迟会极大的拖垮项目的构建速度。

临时创建，为了正常进行单元测试的方式，谨记每种类型的目的不一样

- Dummy

实例划一个空对象

- Fake

按照预期实例化对象

- Mock

模拟实例化对象

- Stub

是 Mock 的延申，对模拟实例化对象的方法进行预期结果定义

- Spy

Spy 和 Mock 的区别是 Spy 操作的是实例化**真实**对象，Stub **部分**方法的返回值

- Selenium

仿真器，比如模拟一个 Tomcat 容易启动一个 WEB 项目来运行单元测试进行测试。

# 如何写好单元测试

## 设计原则（S.O.L.I.D）

- SRP 单一职责原则

软件模块应该只有一个被修改的理由。在大多数情况下，编写Java代码时都会将单一职责原则应用于类。单一职责原则可被视为使封装工作达到最佳状态的良好实践。更改的理由是：需要修改代码。

单一原则，类、方法只干一件事。

- OCP 开闭原则

模块、类和函数应该对扩展开放，对修改关闭。

通过继承和多态扩展来添加新功能。开闭原则是最重要的设计原则之一，是大多数设计模式的基础。

软件建设一个复杂的结构，当我们完成其中的一部分，就应该不要修改它，而是在其基础上继续建设。

- LSP 里式替换原则

在设计模块和类时，必须确保派生类型从行为的角度来看是可替代的。

使用父类的地方都可以用子类替代。

父类最好为抽象类。

子类可实现父类的非抽象方法，尽量不要覆盖重写已实现的方法。

子类可写自身的方法，有自身的特性，在父类的基础上扩建。

子类覆盖重写父类方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松，后置条件（返回值）要更严格。

- ISP 接口隔离原则

减少了代码耦合，使软件更健壮，更易于维护和扩展。

客户端不应该依赖它所不需要的接口。

- DIP 依赖倒置原则

高级模块不应该依赖低级模块，两者都应该依赖抽象。

抽象不应该依赖于细节，细节应该依赖于抽象。

## DRY / KISS / YAGNI / LOD

DRY：不要干重复的事儿。

KISS：不要干复杂的事儿，思从深而行从简。

YAGNI：不要干不需要的事儿，尺度把握尤为重要，超越尺度则会有过度设计之嫌。

LOD：最小依赖。

## 设计模式

高内聚：相近功能放在同一类中，相近功能往往会被同时修改，放到同一个类中在修改时，代码更易维护（指导类本身的设计）

低耦合：类与类之间的依赖关系简单清晰，一个类的代码改动不会或者很少导致依赖类的代码修改（指导类间依赖关系设计）

# 单元测试的好处

- 提高代码正确性

    - 流程判读符合预期，按照步骤运行，逻辑正确。

    - 执行结果符合预期，代码执行后，结果正确。

    - 异常输出符合预期，执行异常或者错误，超越程序边界，保护自身。

    - 代码质量符合预期，效率，响应时间，资源消耗等。

- 发现设计问题

    - 代码可测性差
    
    - 方法封装不合理
    
    - 流程不合理

- 提升代码可读性

易写单测的方法一定是简单好理解的，可读性是高的，反之难写的单测代码是复杂的，可读性差的。

- 顺便微重构

如设计不合理可微重构，保证代码的可读性以及健壮性。

- 提升开发人员自信心

经过单元测试，能让程序员对自己的代码质量更有信心，对实现方式记忆更深。

- 启动速度，提升效率

不用重复启动Pandora容器，浪费大量时间在容器启动上，方便逻辑验证。

- 场景保存（多场景）

在HSF控制台中只能保存一套参数，而单测可保存多套参数，覆盖各个场景，多条分支，就是一个个测试用例。

- CodeReview时作为重点CR的地方

- 好的单测可作为指导文档，方便使用者使用及阅读

# 实践 TDD 后的收益

- 避免了代码难以测试、难以修改、难以阅读的窘况，每个方法的职责更清晰内聚
  
- 先写测试可以帮助我们去思考需求，并提前澄清需求细节，而不是代码写到一半才发现不明确的需求
  
- 由于需求量庞大，很多需求文档的细节不明确，在编写单元测试的时候，会帮战产品反向去完善需求文档
  
- 促进开发人员思考，在编写单元测试的时候会对需求落地思考得更全面
  
- 对于定时任务、消息队列、SDK方法，提供了更便捷的调试方式
  
- 提升了冒烟效率，**持续性**地减少回归bug
  
- 协同开发接手另一个人员开发的模块，当需要在此模块逻辑添加新特性同时保持输出不变的时候，更能体会到单元测试的重要性
  
- 由于在开发的时候，做了单元测试，在做集成测试的时候就会更从容，加快接口的调试速度
  
- 单元测试即文档，开发人员之间交接需求的时候，往往看单元测试比读需求文档更容易理解；网上优秀的开源项目，都会有完整的单元测试，所以大家阅读这类开源项目的时候，往往看单元测试比看文档多
  
- 由于 CI/CD 需求中含有自动化测试的环节，自动化测试包含了白盒和黑盒测试，在0到1的过程中引入了 TDD，帮我们阶段性的完成了白盒自动化测试。

相关优秀文章：
https://mp.weixin.qq.com/s/TjJ31yWTMwr4szz1JqtKcQ
https://mp.weixin.qq.com/s/EZejQam6n_qU5ZLDOv82Rg
https://mp.weixin.qq.com/s/nIntjcrhgLQMiNo0XqPyyg