```yaml
title: 编写优雅的 Go 代码
author: samin
date: 2021-04-06
```

# 代码风格

## goimports

- Go 官方提供的工具

- 自动增删依赖的包引用

- 依赖包按字母排序并分类

- 集成了 gofmt 和依赖包管理

## golint

Go 官方提供的静态检查工具

## 自动化集成

类似 Travis CI / CircleCI / Gitlab CI ，可以集成

# 目录结构

社区中比较常见的目录结构划分：

```text
├── LICENSE.md
├── Makefile
├── README.md
├── api 目录中存放的就是当前项目对外提供的各种不同类型的 API 接口定义文件
├── assets
├── build
├── cmd 当前项目中的可执行文件
├── configs
├── deployments
├── docs
├── examples
├── githooks
├── init
├── internal 私有代码基本放在这里，一般会细分 app 和 pkg 文件夹，替代 src 文件夹（ Go开发一般不会有这个命名的文件夹 ）
├── pkg 存放的就是项目中可以被外部应用使用的代码库
├── scripts 存放由 Makefile 触发的脚本
├── test
├── third_party
├── tools
├── vendor
├── web
└── website
```

# 模块拆分

## 按层拆分

这是一种 Web 框架的最常见架构方式，将服务中的不同组件分成了 Model、View 和 Controller 三层

这种划分层级的方法在 Go 语言中会显得非常冗余，并且如果对项目依赖包的管理不够谨慎时，很容易发生引用循环，出现这些问题的最根本原因其实也非常简单：
1. Go 语言对同一个项目中不同目录的命名空间做了隔离，整个项目中定义的类和方法并不是在同一个命名空间下的，这也就需要工程师自己维护不同包之间的依赖关系；
2. 按照职责垂直拆分的方式在单体服务遇到瓶颈时非常容易对微服务进行拆分，我们可以直接将一个负责独立功能的 package 拆出去，对这部分性能热点单独进行扩容

## 按职责拆分

Go 语言在拆分模块时就使用了完全不同的思路，虽然 MVC 架构模式是在我们写 Web 服务时无法避开的，但是相比于横向地切分不同的层级，Go 语言的项目往往都按照职责对模块进行拆分

对于一个比较常见的博客系统，使用 Go 语言的项目会按照不同的职责将其纵向拆分成 post、user、comment 三个模块，每一个模块都对外提供相应的功能，post 模块中就包含相关的模型和视图定义以及用于处理 API 请求的控制器
 
```text
blog
├── comment  
├── post
│   ├── handler.go  
│   └── post.go
└── user
``` 
 
## 总结

语言和框架层面的设计最终决定了我们应该采用哪种方式对项目和代码进行组织

Java 和 Ruby 这些语言在框架中往往采用水平拆分的方式划分不同层级的职责，而 Go 语言项目的最佳实践就是按照职责对模块进行垂直拆分，将代码按照功能的方式分到多个 package 中，这并不是说 Go 语言中不存在模块的水平拆分，只是因为 package 作为一个 Go 语言访问控制的最小粒度，所以我们应该遵循顶层的设计使用这种方式构建高内聚的模块

# 显式调用

尽可能地消灭项目中的 init 函数，保证显式地进行方法的调用以及错误的处理

## init 函数

不能大量使用，这种隐式调用应该非常谨慎

不应该在 init 中做过重的初始化逻辑，而是做一些简单、轻量的前置条件判断

## error 

1. 使用 error 实现错误处理 — 尽管这看起来非常啰嗦；
2. 将错误抛给上层处理 — 对于一个方法是否需要返回 error 也需要我们仔细地思考，向上抛出错误时可以通过 errors.Wrap 携带一些额外的信息方便上层进行判断；
3. 处理所有可能返回的错误 — 所有可能返回错误的地方最终一定会返回错误，考虑全面才能帮助我们构建更加健壮的项目

# 面向接口

面向接口编程是一个老生常谈的话题，接口的作用其实就是为不同层级的模块提供了一个定义好的中间层，上游不再需要依赖下游的具体实现，充分地对上下游进行了解耦

这种编程方式不仅是在 Go 语言中是被推荐的，在几乎所有的编程语言中，我们都会推荐这种编程的方式，它为我们的程序提供了非常强的灵活性，想要构建一个稳定、健壮的 Go 语言项目，不使用接口是完全无法做到的。

如果一个略有规模的项目中没有出现任何 type ... interface 的定义，那么作者可以推测出这在很大的概率上是一个工程质量堪忧并且没有多少单元测试覆盖的项目，我们确实需要认真考虑一下如何使用接口对项目进行重构。

> 单元测试是一个项目保证工程质量最有效并且投资回报率最高的方法之一，作为静态语言的 Golang，想要写出覆盖率足够（最少覆盖核心逻辑）的单元测试本身就比较困难，因为我们不能像动态语言一样随意修改函数和方法的行为，而接口就成了我们的救命稻草，写出抽象良好的接口并通过接口隔离依赖能够帮助我们有效地提升项目的质量和可测试性，我们会在下一节中详细介绍如何写单元测试。

『依赖接口，不要依赖实现』，也就是面向接口编程。

## 总结

在这一小节中总共介绍了 Go 语言中三个经常会打交道的『元素』— init 函数、error 和接口，我们在这里主要是想通过三个不同的例子为大家传达的一个主要思想就是尽量使用显式的（explicit）的方式编写 Go 语言代码。

# 单元测试

写代码并不是一件多困难的事情，不过想要在项目中写出可以测试的代码并不容易，而优雅的代码一定是可以测试的，我们在这一节中需要讨论的就是什么样的代码是可以测试的。

## suite

按照簇进行组织，其实就是对 Go 语言默认的测试方式进行简单的封装，我们可以使用 stretchr/testify 中的 suite 包对测试进行组织

## BDD

行为驱动开发（BDD）和测试驱动开发（TDD）都是一种保证工程质量的方法论

## Mock

> golang/mock

常见需要 mock 的情况：

1. 接口
   
2. 数据库

3. HTTP 请求
   
4. Redis、缓存以及其他依赖

## 猴子补丁

bouk/monkey 能够通过替换函数指针的方式修改任意函数的实现

## 断言

单元测试的 assert 包，它提供了非常多的断言方法帮助我们快速对期望的返回值进行测试

## 总结

学习写好单元测试一定会有一些学习曲线和不适应，甚至会在短期内影响我们的开发效率，但是熟悉了这一套流程和接口之后，单元测试对我们的帮助会非常大，每一个单元测试都表示一个业务逻辑，每次提交时执行单元测试就能够帮助我们确定新的代码大概率上不会影响已有的业务逻辑，能够明显地降低重构的风险以及线上事故的数量

- gomock：最标准的也是最被鼓励的方式
  
- sqlmock：处理依赖的数据库
  
- httpmock：处理依赖的 HTTP 请求
  
- monkey：万能的方法，但是只在万不得已时使用，类似的代码写起来非常冗长而且不直观
  
- 可测试：意味着面向接口编程以及减少单个函数中包含的逻辑，使用『小方法』
  
- 组织方式：使用 Go 语言默认的 Test 框架、开源的 suite 或者 BDD 的风格对单元测试进行合理组织
  
- Mock 方法：四种不同的单元测试 Mock 方法
  
- 断言：使用社区的 testify 快速验证方法的返回值
