```yaml
title: 算法入门 
author: samin
date: 2021-05-04
```

# 算法学习方法

改变自己的学习方法（不要死磕）

五遍刷题法，五毒神掌，最大误区：只做一遍

看高评题解

# 数组

## 特点

1. 在内存中开辟一段连续空间
2. 可以随机访问任何一个地址，速度非常快，复杂度为O(1)
3. 新增最坏时间复杂度是O(n)，最快的是O(1)，新增有一个 `ensureCapacity` 方法，目的是确认容量，长度不够的情况下使用会 `new` 一个新数组，把老数据拷贝到新数据，所以频繁的对 `ArrayList` 的新增操作会涉及多次的 `ensureCapacity` 操作

# 链表

## 特点

1. 需要用对象表示，有 `value` 和指向属性
2. 只有一个 `next` 的叫单链表
3. 有 `next` 和 `prev` 双指向的叫双向链表
4. 头指针用 `Head` 表示，尾指针用 `Tail` 表示，`Tail` 指向空指针，或者可以指回 `Head`，那么就是循环列表
5. 增加和删除节点都是 O(1) 的操作，查询是O(n)

# 跳表（Skip List）

## 由来

数组列表的查询快，操作慢；链表的操作快，查询慢。所以针对链表优化延伸出跳表，能做到查询和操作都快的特点。对标的是平衡树（AVL）和二分查找，是一种插入\删除\搜索都是 O(logn)的数据结构。

## 特点

1. 原理简单、容易实现、方便拓展、效率更高
2. 里面的元素一定是有序的
3. 有多级索引
4. 维护成本高
5. 升维思想+空间换时间

## 应用场景

- LRU Cache
- Redis有序集合(sorted set)在节点元素较大或者元素数量较多时使用跳跃表实现,Redis的跳跃表实现由 zskiplist 和 zskiplistnode 两个结构组成,其中 zskiplist 用于保存跳跃表信息(比如表头节点、表尾节点、长度),而 zskiplistnode 则用于表示跳跃表节点

# 数组和链表

## 数组

### 优点

- 简单易用
- 无序数组的插入速度很快,效率为O(1)
- 有序数组的查找速度较快(较无序数组),效率为O(logN)

#### 有序数组
- 添加数据
  查找插入位置用二分查找是O(log2n)。但是数组的插入操作为了保证有序性需要将插入位置后的元素全部后移一位，这需要O(n)
  总时间复杂度：O(logn)+O(n)=O(n)

- 删除数据
  使用二分查找找到删除位置，再把删除位置后的所有元素前移一位。总时间同添加数据一样:O(logn)+O(n)=O(n)

- 查找数据
  二分法查找数据。时间复杂度为O(logn)

- 修改数据
  二分查找到数据后，进行修改。时间复杂度为O(logn)
  但因为是有序数组，还要进行排序。因为有序数组大部分都是有序，即使使用冒泡排序时间开销也不会太大，所以此处我们使用冒泡序。冒泡排序时间复杂度为O(n²)。
  总的时间复杂度:O(n²)+O(logn)

#### 无序数组
- 添加数据
  空间足够，直接添加在后面，时间复杂度为O(1)
  空间不足，整个数组移到另一个空间，再添加元素。总的时间复杂度：O(1)+O(n)=O(n)

- 删除数据
  使用顺序查找找到删除位置，再把删除位置后的所有元素前移一位。
  总时间复杂度:O(n)+O(n)=O(n)

- 查找数据
  使用顺序查找找到数据，时间复杂度：O(n)

- 修改数据
  顺序查找到数据后，进行修改。时间复杂度为O(n)

### 缺点

- 数组的查找、删除很慢
- 数组一旦确定长度,无法改变

## 链表

### 优点

- 可以无限扩容(只要内存够大)
- 在链表头的新增、删除很快,效率为O(1)

### 缺点

- 查找很慢
- 在非链表头的位置新增、删除很慢,效率为O(N)

# 二叉树

二叉树是一种特殊的树,它的每个节点最多含有两个子树

## 深度与高度的区别

- 深度为根到节点的距离
- 高度是节点到叶的距离

> 口诀：根深叶高

## 特点

二叉搜索树的查找、新增、删除的效率为O(logN)(这是理想状态下,如果树是不平衡的效率会降到O(N)

- 数据是按照规则有序的方式排列的
- 进行新增、查找、删除的时候使用了二分查找法
- 树对所有常用的数据存储操作都有很高的效率
- **二叉树是平衡的**，它的效率为: `O(logN)`，如果二叉树是不平衡的(最极端的情况,存入树中的数据是升序或降序排列的，那么二叉树就是链表，效率为: `O(N)`)

## 缺点

二叉树是极端不平衡的(此时的二叉树就是一个链表)，它的效率为 `O(N)` ，即使数值是随机的，如果数据的量够大，也有可能有一部分的数值是有序的(就像你抛硬币的时间足够长，会有一段时间出现一直抛正面或反面)，造成二叉树会变成是局部不平衡的，这样它的效率会介于 `O(logN)` 到 `O(N)`

## 遍历方式

- DFS（深度优先算法）
    - 先序遍历
        - 根 左子树 右子树
    - 中序遍历（最常用）
        - 左子树 根 右子树
        - 遍历结果是递增数列
        - 逆方向（右 根 左），是递减数列
    - 后序遍历
        - 左子树 右子树 根

- BFS（广度优先算法）
    - 层序遍历

前序遍历可以确定root的位置 （DLR）
中序遍历可以确定左子树 (LDR)
后序遍历可以确定右子树 (LRD)

# 二叉树/二叉搜索树

## 说明

Binary Search Tree （BST）

## 特点

1. 其实由链表升级而来，假设每个 `node` 有左右两个节点，那么从 `Head` 开始，分化为二叉树
2. 查询、新增、删除节点的复杂度都是 O(logn)

## 特殊记忆

1. `Linked List` 是特殊的 `Tree` (保持只有一个子节点的树就是链表)
2. `Tree` 是特殊化的 `Graph` (没有环的图就是树)

## 遍历方式

1. 前序（Pre-Order） : 根-左-右
2. 中序（In-Order）：左-根-右
   因为符合二叉树特性（左子树小与根节点小与右子树）去输出，所以是升序排列，倒序为降序排列。
3. 后序（Post-Order）：左-右-根

# 平衡二叉搜索树（AVL）

## 说明

Balanced Binary Search Tree

## 特点

1. AVL 是严格平衡的BST ，改进了 BST，不会出现退化为链表的情况，导致搜索算法复杂度为O(n)
2. AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右
3. AVL树在执行删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)

# 红黑树

## 说明

Red-Black Tree（RBT）

## 特点

1. 二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。红黑树是一种折中策略，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率。
2. 每个红色结点的两个子节点必须是黑色
3. 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点
4. 查找效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，但也远远好于BST。插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。

# B~树/B+树 (B-Tree)

## 特点

1. 红黑树在纯内存的搜索结果已经很快，对于数据量大的查找操作需要提前在磁盘中建立好结构，由于磁盘IO频繁非常耗时，所以导致所有二叉树的速度都非常慢，所以B树解决了这一问题。
2. 查找代价： B-Tree作为一个平衡多路查找树(m-叉)。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。
3. 插入代价： B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。
4. 删除代价：B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次
   读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写
   访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）
5. B-Tree效率总结： 由于考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(**读写磁盘次数的降低**)。
6. B+树是B~树的一种变体，在磁盘查找结构中，B+树更适合文件系统的磁盘存储结构。
7. B+树严格意义上说已经不是树，它的叶子结点之间也有指针链接。B+树的非终结点中并不含有关键字的信息，需要查找的关键字的全部信息都包含在叶子结点上。非终结点中只作为叶子结点关键字的索引而存在。

# 递归

## 特点

1. 每一层递归互不影响
2. 总体流程为 `递归终结条件判断` -> `处理当前层逻辑` -> `下探到下一层` -> `清理当前层 `

## 思维

1. 不要进行人肉递归（不建议使用人工枚举递归每一层的状态，从来而尝试理解递归）
2. 找到最近最简的方法，将其拆成可重复解决的问题（最近重复子问题）
3. 数学归纳法的思维

## Java模板

```java
public void recurison(int level,int param){
    
    // terminator
    if(level > MAX_LEVEL){
        // process result
        return;
    }
    
    // process current logic
    process(level,param);
    
    // drill down
    recurison(level+1,newParam);
    
    // restore current status
}
```
# 常考算法

## 初级

两数之和/整数反转/回文数/整数转罗马数&罗马数字转整数/最长公共前缀/有效括号/合并两个有序链表/删除排序数组中的重复项/移除数组中的指定元素/实现strStr()函数

## 中级

两数相加/无重复字符串的最长子串/最长回文子串/Z字形变换/字符串转换整数(atoi)/三数之和/最接近的三数之和/电话号码的字母组合/删除链表的倒数第n个节点/括号生成/两两交换链表中的节点/盛水最多的容器/下一个排列/搜索旋转排序数组/摆动排序

## 高级

寻找两个有序数组的中位数/正则表达式匹配/合并K个排序链表/K个一组翻转链表/单词接龙/寻找最近的回文数/地下城游戏/学生出勤记录/和最少为K的最短子数组/猫和老鼠

## 专题

LRU算法实现（LinkedHashMap）/二叉树遍历/二分算法/斐波那契数列/大整数/常用排序算法/手撕代码