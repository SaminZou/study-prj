```yaml
title: 订单30分钟失效研发方案
author: samin
date: 2021-11-14
```

# 背景

- 生成订单30分钟未支付，则自动取消

- 生成订单60秒后，给用户发短信

以上两点需求，都是需要延时任务来处理

# 延时任务 vs 定时任务

- 定时任务有明确的触发时间，延时任务没有

- 定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期

- 定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务

# 方案分析

## 数据库轮询

通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行 update 或 delete 等操作

优点：

简单易行，支持集群操作

缺点：

1. 对服务器内存消耗大

2. 存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟

3. 假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大

## JDK 的延迟队列

该方案是利用JDK自带的DelayQueue来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入DelayQueue中的对象，是必须实现Delayed接口的。

重要方法：

- poll():获取并移除队列的超时元素，没有则返回空

- take():获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果

优点：

效率高，任务触发时间延迟低。

缺点：

1. 服务器重启后，数据全部消失，怕宕机

2. 集群扩展相当麻烦

3. 因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现 OOM 异常

4. 代码复杂度较高

## 时间轮算法

优点：

效率高，任务触发时间延迟时间比delayQueue低，代码复杂度比delayQueue低。

缺点：

1. 服务器重启后，数据全部消失，怕宕机

2. 集群扩展相当麻烦

3. 因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常

## redis缓存

利用redis的zset，zset是一个有序集合，每一个元素(member)都关联了一个score，通过score排序来取集合中的值。

重要方法：

- 添加元素:ZADD key score member [[score member] [score member] …]

- 按顺序查询元素:ZRANGE key start stop [WITHSCORES]

- 查询元素score:ZSCORE key member

- 移除元素:ZREM key member [member …]

处理多个线程消费同一个资源的解决方案：

1. 用分布式锁，但是用分布式锁，性能下降了，该方案不细说。

2. 对ZREM的返回值进行判断，只有大于0的时候，才消费数据。

## Redis Keyspace Notifications

优点：

1. 由于使用Redis作为消息通道，消息都存储在Redis中。如果发送程序或者任务处理程序挂了，重启之后，还有重新处理数据的可能性。

2. 做集群扩展相当方便

3. 时间准确度高

缺点：

需要额外进行redis维护

## 消息队列

RabbitMQ 的延时队列。RabbitMQ具有以下两个特性，可以实现延迟队列

1. RabbitMQ可以针对 Queue 和 Message 设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter

2. lRabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了dead letter，则按照这两个参数重新路由

优点：

高效，可以利用 RabbitMQ 的分布式特性轻易的进行横向扩展，消息支持持久化增加了可靠性。

缺点：

本身的易用度要依赖于 RabbitMq的运维。因为要引用 RabbitMq，所以复杂度和成本变高