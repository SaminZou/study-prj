```yaml
title: 分布式锁 
author: samin
date: 2022-01-09
```

# 分布式特点

- 单点故障（Single Point Failure）

- 无状态

# 分布式锁和 JVM 锁异同

在可以使用两种锁的时候，分布式锁一定没有 JVM 性能好，因为有网络通讯的损耗

并不是有了分布式锁，就可以解决高并发问题，而忽略单机的 IO 问题了，所以需求尽量在先考虑 JVM 锁无法处理的情况下，再考虑分布式锁。因为使用分布式锁意味着一定用到了中间件，中间件承接太多请求，IO（系统调用） 吞吐量就会成为一个瓶颈。

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/分布式锁和JVM锁1.png)

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/分布式锁和JVM锁2.png)

并不是增加了机器，就可以理解为系统的性能整体提升了，就比如分布式锁的正确使用，以及为了做到服务无状态把一些本地数据放到中间件去共同访问等损耗。

同一个功能，分布式肯定比单机要慢。分布式的意义在于分治，间接可以提升速度。

只要用了锁，程序一定是串行化处理。

# 分布式锁实现方式

- MySQL
- Redis
- Zookeeper
- Etcd

# 两大类分布式锁

- 类 cas 自旋式分布式锁，询问的方式，尝试加锁
    - Redis * 
      - woker 是单线程串行的，天生适合分布式锁
      - 一般使用 setnx + timeout
      - 发布订阅，消息队列+超时，可以减少多节点抢锁的频率
      - 有可能出现业务线程还没处理完分布式锁就timeout的情况，增加监控线程增加timeout 
      - 锁增加 UUID 标识，区别不同业务的锁
    - MySQL

- event 事件通知锁的变化，等待被告知
    - Zookeeper *
    - Etcd
    
> 自旋方式获取分布式锁的方式会

# 轻盈的 “重量级分布式锁”
