```yaml
title: 分布式一致性
author: samin
date: 2021-05-15
```

# 分布式理论和协议

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/CAP一致性.png)

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/CAP可用性.png)

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/CAP分区容忍性.png)

**CAP 理论面向对象是一个服务的集群**

理论（学术）：CAP、AP、CP、BASE

> CAP 定理主要描述的是状态,BASE 理论等工程结论是对状态的后续处理
> 
> BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）
> 
> BASE 理论是实践工程的理论，它弥补了CAP 理论过于抽象的问题，也同时解决了 AP 系统的总体工程实践思想，是分布式系统的核心理论之一，我们将在下一篇文章里，详细的讲解此套理论
>
> 参考：https://cloud.tencent.com/developer/news/751991

一致性协议：2PC、3PC、Paxos、Raft、ZAB（Zookeeper）

## CP 

Zookeeper 的设计是 CP，在单点故障的时候，是不可用的

## AP

Eureka 是 AP，挂掉几个节点，剩余节点都可以正常使用，只不过取到的数据可能是不一致的；只要有一个 Eureka 节点还在，服务都还可以使用

# 什么是分布式事务

## 和数据库事务的区别

谈到事务，我们就会想到数据库事务，很容易就想到原子性、一致性、持久性、隔离性。

分布式事务跟数据库事务有点不一样，它是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单来说，分布式事务指的就是分布式系统中的事务，它的存在就是为了保证不同数据库节点的数据一致性。

## 分布式事务基础

分布式事务需要需要知道CAP理论和BASE理论。

### BASE 理论

BASE 理论， 是对CAP中AP的一个扩展，对于我们的业务系统，我们考虑牺牲一致性来换取系统的可用性和分区容错性。BASE是Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写。

- 基本可用是指，通过支持局部故障而不是系统全局故障来实现的；
- Soft State表示状态可以有一段时间不同步；
- 最终一致，最终数据是一致的就可以了，而不是实时保持强一致。

## 分布式事务的几种解决方案

- 2PC(二阶段提交)方案，事务的提交分为两个阶段：准备阶段和提交执行方案。

- TCC（即Try、Confirm、Cancel），它采用了补偿机制，核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。

- 本地消息表，它的核心思想就是将分布式事务拆分成本地事务进行处理。

- 最大努力通知，实现最大努力通知，可以采用MQ的ack机制。

- Saga事务，它的核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。

业界目前使用本地消息表这种方案是比较多的，它的核心思想就是将分布式事务拆分成本地事务进行处理。可以看一下基本的实现流程图吧：

![本地消息表方案](https://raw.githubusercontent.com/SaminZou/pic-repo/master/MircoService/本地消息表方案.jpg)

> 对于消息发送方

- 首先需要有一个消息表，记录着消息状态相关信息。
- 业务数据和消息表在同一个数据库，即要保证它俩在同一个本地事务。
- 在本地事务中处理完业务数据和写消息表操作后，通过写消息到MQ消息队列。
- 消息会发到消息消费方，如果发送失败，即进行重试。

> 消息消费方

- 处理消息队列中的消息，完成自己的业务逻辑。
- 此时如果本地事务处理成功，则表明已经处理成功了。
- 如果本地事务处理失败，那么就会重试执行。
- 如果是业务上面的失败，给消息生产方发送一个业务补偿消息，通知进行回滚等操作。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

# 2PC vs 3PC

## 2PC（二阶段提交协议）

2PC（Two-Phase Commit） 即两阶段提交，是将整个事务流程分为两个阶段：准备阶段（Prepare Phase）和提交阶段（Commit Phase）。

部分关系型数据库支持2PC协议，如Oracle、MySql。

![2pc](https://raw.githubusercontent.com/SaminZou/pic-repo/8427edecaac0b947dc52f3474aed3af62862d537/DistributedSystem/%E4%B8%80%E8%87%B4%E6%80%A7/2pc.png)

### 阶段一

1. 事务询问；协调者向各参与者发送事务内容，询问是否可提交事务，并等待各个参与者响应。
2. 各个参与者执行事务，并写Undo/Redo日志，此时事务已经执行，但并没有提交事务。 Undo日志记录的是修改前的数据，用于数据库事务回滚；Redo日志记录的是修改后的数据，用于提交事务后写入数据。
3. 各参与者向协调者反馈事务询问的响应。

### 阶段二

- 成功提交事务

阶段一的事务询问，各个参与者的响应都是Yes

1. 协调者向各参与者发送 commit 请求（事务提交）。
2. 各个参与者收到 commit 请求后，真正的提交事务，并在完成后释放事务执行过程中用到的锁资源。
3. 参与者完成事务后，向协调者发送 Ack 信息。（Ack是确认字符，在数据通信中，接受站发给发送站的一种传输类控制字符，表示发来的数据已确认接收无误。）
4. 协调者接收到所有参与者的 Ack 信息后，完成事务。

- 失败中断事务

任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者依然无法获取所有参与者的反馈响应，那么就会中断事务。

1. 协调者向所有参与者发送 RollBack 请求（回滚请求）。
2. 参与者接收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的锁资源。
3. 参与者在完成事务回滚之后，向协调者发送 Ack 信息。
4. 中断事务：协调者接收到所有参与者反馈的 Ack 信息后，完成事务中断。

## 3PC（三阶段提交协议）

3PC（Three Phase Commit），是2PC的改进版，是由canCommit、preCommit、doCommit三个阶段组成的事务处理协议。

![3pc](https://raw.githubusercontent.com/SaminZou/pic-repo/8427edecaac0b947dc52f3474aed3af62862d537/DistributedSystem/%E4%B8%80%E8%87%B4%E6%80%A7/3pc.png)

### canCommit阶段

1. 事务询问

   协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交的操作，并等待参与者响应。

2. 各参与者向协调者反馈事务询问的响应

   参与者收到canCommit请求后，如果认为自身可以顺利执行事务提交，就向协调者反馈Yes响应，否则返回No响应。

### preCommit阶段

根据事务询问的结果，协调者会选择执行事务预提交，或者中断事务。

- 若所有参与者都反馈了Yes响应，则执行事务预提交：

    1. **发送预提交请求**；协调者向所有的参与者发送 preCommit 请求，并进入prepared阶段。
    2. **事务预提交**；参与者收到preCommit请求后，会执行事务操作，并写入Undo/Redo日志。
    3. **各参与者向协调者反馈预提交结果**；若参与者成功执行了事务，则反馈Ack。

- 若有参与者反馈了No响应，或者等待超时之后，仍然无法获取所有参与者的响应，则执行中断事务：

    1. **发送中断事务请求**；协调者向各参与者发送abort请求。
    2. **中断事务**；参与者收到abort请求或者等待协调者请求超时，参与者都会中断事务。

## doCommit阶段

该阶段也会出现两种情况：分别是事务提交和事务回滚。

- 若协调者收到了所有参与者的Ack响应，则会执行事务提交

    1. **发送事务提交请求**；协调者向所有的参与者发送 doCommit 请求。
    2. **提交事务**；参与者收到 doCommit 请求后，正式执行事务提交操作，并将事务执行过程中占用的锁资源释放。
    3. **反馈事务提交结果**；参与者完成事务提交操作后，向协调者反馈Ack信息。
    4. **完成事务**；协调者收到所有参与者发送的Ack响应，完成事务。

- 否则中断事务

    1. **发送中断请求**；协调者向所有的参与者发送abort请求。
    2. **事务回滚**；参与者收到abort请求后，根据Redo日志进行事务回滚操作，并在回滚完成后释放掉整个事务执行过程中占用的锁资源。
    3. **反馈事务回滚结果**；参与者在事务完成后，向协调者反馈Ack信息。
    4. **中断事务**；协调者收到所有参与者响应的Ack信息，中断事务。

## 优缺点

### 2PC 优点

原理简单，实现方便。

### 2PC 缺点

- 同步阻塞

  这是2PC协议存在的最明显也是最大的问题，在二阶段提交的执行过程中，所有参与该事务提交的逻辑都处于阻塞状态，各参与者在等待其他参与者响应的过程中，无法执行其他操作，这种同步阻塞极大的限制了分布式系统的性能。

- 单点故障问题

  在二阶段提交的执行过程中，协调者是非常重要的，一旦协调者出现问题，那整个流程将无法进行下去，最重要的是：其他参与者会一直处于资源锁定状态，无法完成事务操作。

- 数据不一致

  当协调者发送完所有的 commit 请求后发生了局部网络异常，或者协调者未发送完所有的 commit 请求自身就发生了崩溃，导致只有部分参与者收到了 commit 请求，最终会发生严重的数据不一致。

- 过于保守

  在二阶段提交的询问阶段，参与者出现故障而导致协调者一直无法获取所有参与者的响应的话，协调者只能依靠自身的超时机制去判断是否中断事务，这种策略过于保守。 是二阶段提交协议没有设计完善的容错机制，任何一个节点失败都会导致整个事务的失败。

### 3PC 优点

- 协调者和参与者都设置了超时机制（2PC中只有协调者设置了超时机制），避免了参与者长期无法和协调者通信（协调者故障）的情况下，参与者无法释放锁资源的情况，侧面降低了整个事务阻塞的时间和范围；

- 增加了一个缓冲阶段，保证了在最后提交阶段之前，各节点的状态是一致的；

### 3PC 缺点

3PC进入第三阶段可能会出现的问题

1. 协调者自身出现故障；

2. 协调者与参与者之间网络故障。

以上两种故障只要出现一种，都会导致参与者无法收到协调者发送的doCommit请求或abort请求，这可能会导致严重的数据不一致问题。

> 没有彻底解决数据不一致问题；由于第三阶段可能会发生上面提到的问题，一旦参与者没有正常接收到协调者发送的abort请求，参与者会在自身等待超时后，提交事务并释放资源，将会导致数据不一致问题。