```yaml
title: 分布式入门
author: samin
date: 2022-01-11
```

# 分布式理论和协议

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/CAP一致性.png)

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/CAP可用性.png)

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/CAP分区容忍性.png)

**CAP 理论面向对象是一个服务的集群**

理论（学术）：CAP、AP、CP、BASE

> CAP 定理主要描述的是状态,BASE 理论等工程结论是对状态的后续处理
>
> BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）
>
> BASE 理论是实践工程的理论，它弥补了CAP 理论过于抽象的问题，也同时解决了 AP 系统的总体工程实践思想，是分布式系统的核心理论之一，我们将在下一篇文章里，详细的讲解此套理论
>
> BASE 最重要是为 CAP 提出了最终一致性的解决方案，BASE 强调牺牲高一致性，从而获取可用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了
> 
> 参考：https://cloud.tencent.com/developer/news/751991

一致性协议：2PC、3PC、Paxos、Raft、ZAB（Zookeeper）

## CP

Zookeeper 的设计是 CP，在单点故障的时候，是不可用的

## AP

Eureka 是 AP，挂掉几个节点，剩余节点都可以正常使用，只不过取到的数据可能是不一致的；只要有一个 Eureka 节点还在，服务都还可以使用

# 为什么出现分布式问题

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/分布式的产生.png)

## 分布式需要解决的问题

- 分布式 ID
  解决集群服务同时需要 ID 的问题

- 分布式事务（BASE）
  解决不同服务器服务协作问题

- 分布式锁（CAP）
  解决集群服务产生并发问题

# 分布式常见问题

## 注册中心，选择 AP 还是 CP ？

### 服务注册中心解决的问题

- 服务注册

  实例将自身服务信息注册到注册中心，这部分信息包括服务的主机 IP 和服务的 Port，以及暴露服务自身状态和访问协议信息等

- 服务发现

  实例请求注册中心所依赖的服务信息，服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/注册中心作用.png)

### 主流服务注册中心

- Dubbo 的 Zookeeper

- Spring Cloud 的 Eureka

- Consul

- RocketMQ 的 nameServer

- HDFS 的 nameNode

- RocketMQ 的 nameServer

### Zookeeper 选择 CP

Zookeeper 保证 CP，即任何时刻对 Zookeeper 的访问请求能得到一致性的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务的可用性

从实际情况来分析，在使用 Zookeeper 获取服务列表时，如果 ZK 正在选举或者 ZK 集群中半数以上的机器不可用，那么将无法获取数据。所以说，ZK 不能保证服务可用性

### Eureka 选择 AP

Eureka 保证 AP，Eureka 在设计时优先保证可用性，每一个节点都是平等的

一部分节点挂掉不会影响到正常节点的工作，不会出现类似 ZK 的选举 Leader 的过程，客户端发现向某个节点注册或连接失败，会自动切换到其他的节点

只要有一台 Eureka 存在，就可以保证整个服务处在可用状态，只不过有可能这个服务上的信息并不是最新的信

### Zookeeper 和 Eureka 数据一致性问题

先要明确一点，Eureka 的创建初心就是为一个注册中心，但是 ZK 更多是作为分布式协调服务的存在。

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/AP和CP读写区别.png)

### 总结

对于服务注册来说，针对同一个服务，即使注册中心的不同节点保存的服务注册信息不相同，也并不会造成灾难性的后果；
对于服务消费者来说，能消费才是最重要的，就算拿到的数据不是最新的数据，消费者本身也可以进行尝试失败重试。总比为了追求数据的一致性而获取不到实例信息整个服务不可用要好；
所以，对于服务注册来说，可用性比数据一致性更加的重要，选择 AP。

## 分布式锁，选择 AP 还是 CP ？

### 常用方式

- 基于 Redis 实现分布式锁

- 基于 Zookeeper 实现分布式锁

### 总结

首先得了解清楚我们使用分布式锁的场景，为何使用分布式锁，用它来帮我们解决什么问题，先聊场景后聊分布式锁的技术选型;
无论是 Redis，ZK，例如 Redis 的 AP 模型会限制很多使用场景，但它却拥有了几者中最高的性能;
Zookeeper 的分布式锁要比 Redis 可靠很多，但他繁琐的实现机制导致了它的性能不如 Redis，而且 ZK 会随着集群的扩大而性能更加下降;
简单来说，先了解业务场景，后进行技术选型;

## 分布式事务的 CAP 和 BASE ？

如果说到事务，ACID 是传统数据库常用的设计理念，追求强一致性模型，关系数据库的 ACID 模型拥有高一致性 + 可用性，所以很难进行分区。

在微服务中 ACID 已经是无法支持，我们还是回到 CAP 去寻求解决方案，不过根据上面的讨论，CAP 定理中，要么只能 CP，要么只能 AP。

### 分布式事务都是遵循 BASE 理论的最终一致性模型

- 两阶段提交（ 2PC ），XA 协议

- 补偿事务（ TCC ）
  比起 2PC 增加了超时机制防止同步阻塞，超时后进行补偿

- 本地消息表（ Ebay ）

- MQ 事务消息

## RocketMQ 高可用，选择 AP 还是 CP ？

### 同异步刷盘

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/RocketMQ刷盘.png)

### 同异步复制

- 同步复制：是等 Master 和 Slave 均写成功后才反馈给客户端写成功状态

- 异步复制：是只要 Master 写成功即可反馈给客户端写成功状态

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/RocketMQ复制.png)

### 刷盘复制机制的选择

![](https://raw.githubusercontent.com/SaminZou/pic-repo/master/BlogPicture/RocketMQ刷盘复制机制的选择.png)

通常情况下，应该把 Master 和 Slave 设置成 ASYNC_FLUSH 的刷盘方式，主从之间配置成 SYNC_MASTER 的复制方式，这样即使有一台机器出故障，仍然可以保证数据不丢

## 业务系统对 AP 和 CP 的选择

究竟是选 CA 还是选 CP，真的在于对业务的了解，例如金钱，库存相关会优先考虑 CP 模型，例如社区发帖相关可以优先选择 AP 模型，这个说白了基于对业务的了解是一个选择和妥协的过程。