# JVM 编译优化

前端编译与优化：我们最常见的前端编译器是 javac，它的优化更偏向于代码结构上的优化，它主要是为了提高程序员的编码效率，不怎么关注执行效率优化；例如，数据流和控制流分析、解语法糖等等

后端编译与优化：后端编译包括 "即时编译[JIT]" 和 "提前编译[AOT]"
，区别于前端编译器，它们最终作用体现于运行期，致力于优化从字节码生成本地机器码的过程(它们优化的是代码的执行效率)

## 分层编译

分为：解释模式、编译模式、混合模式

\# 可以查看到编译模式
$ java -version

| JVM 自己根据宿主机决定自己的运行模式, "JVM 运行模式"；[客户端模式-Client、服务端模式-Server]
，它们代表的是两个不同的即时编译器，C1(Client Compiler) 和 C2 (Server Compiler)

## 即时编译器

1. 解释模式

不使用即时编译器进行后端优化

```
# 强制虚拟机运行于 "解释模式" 
-Xint
# 禁用后台编译
-XX:-BackgroundCompilation
```

2. 编译模式

即时编译器会在运行时，对生成的本地机器码进行优化，其中重点关照热点代码

```
# 强制虚拟机运行于 "编译模式"
-Xcomp
# 方法调用次数计数器阈值，它是基于计数器热点代码探测依据[Client模式=1500,Server模式=10000]
-XX:CompileThreshold=10
# 关闭方法调用次数热度衰减，使用方法调用计数的绝对值，它搭配上一配置项使用
-XX:-UseCounterDecay
# 除了热点方法，还有热点回边代码[循环]，热点回边代码的阈值计算参考如下：
-XX:BackEdgeThreshold  = 方法计数器阈值[-XX:CompileThreshold] * OSR比率[-XX:OnStackReplacePercentage]
# OSR比率默认值：Client模式=933，Server模式=140
-XX:OnStackReplacePercentag=100
```

| 所谓 "即时"，它是在运行过程中发生的，所以它的缺点也也明显：在运行期间需要耗费资源去做性能分析，也不太适合在运行期间去大刀阔斧的去做一些耗费资源的重负载优化操作

3. 提前编译器

只支持 G1 或者 Parallel 垃圾收集器，且只存在JDK 9 以后的版本

JDK 9 以后的版本可以使用这个参数打印相关信息：[-XX:PrintAOT]

