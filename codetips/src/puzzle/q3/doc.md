```yaml
title: 关于线程池线程数的限制
author: samin
date: 2021-06-04
```

# 背景

网上流传着这样一个公式：

    CPU 密集型的程序线程数 = 核心数 + 1
    I/O 密集型的程序线程数 = 核心数 * 2

实际上，线程池的线程数定义是需要大量的实际调试才能得出来比较适合当前项目的配置。

# 实验

使用 `Cpu100Run.java` 程序，可以模拟启动多线程（ CPU 密集型 ）进行工作，可以用 `top` 指令观测到服务器的情况

可以看出，即使超出了 `核心数 + 1` 线程数，服务器还是能够正常高效运行，因为当线程数超出 CPU 核心数的时候，会触发操作系统的调度，给每个线程分配 CPU 时间片资源，不可否认的是，当线程数的增多，操作系统会更频繁的执行切换线程执行，导致程序处理开始出现性能问题

每次切换会伴随着寄存器数据更新，内存页表更新等操作。随着线程数的增加，线程切换的过于频繁，甚至在单位时间内切换的耗时已经大于程序执行的时间，就会导致CPU资源过多的浪费在上下文切换上，而不是在执行程序，得不偿失

# loadavg

在并发编程的时候，需要结合 CPU 使用率和 loadavg 来综合分析服务器的情况，一般而言，排队越多的线程数待执行会导致 loadavg 越高

# 为什么 I/O 密集型的程序线程数设置数量一般比 CPU 密集型的要多

大多程序在运行时都会有一些 I/O 操作，可能是读写文件，网络收发报文等，这些 I/O 操作在进行时时需要等待反馈的。比如网络读写时，需要等待报文发送或者接收到，在这个等待过程中，线程是等待状态，CPU 没有工作。此时操作系统就会调度 CPU 去执行其他线程的指令，这样就利用了 CPU 这段空闲期，提高了CPU的利用率

# 总结

一个极端的线程（无 I/0 操作的计算类型程序），就可以把单个核心的利用率跑满，多核心 CPU 最多只能同时执行等于核心数的"极端"线程数，所以 `核心数 + 1` 的设计并没多大收益（导致不必要的切换，造成负载过高，只会让执行更慢）
  
I/O 等暂停类操作时，CPU 处于空闲状态，操作系统调度 CPU 执行其他线程，可以提高 CPU 利用率，同时执行更多的线程；I/O 事件的频率越高，或者等待/暂停时间越长，CPU的空闲时间也就更长，利用率越低，操作系统可以调度 CPU 执行更多的线程

不要纠结设置多少线程了。没有标准答案，一定要结合场景，带着目标，通过测试去找到一个最合适的线程数。





